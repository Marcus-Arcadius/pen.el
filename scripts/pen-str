#!/bin/bash

# A string preprocessor/postprocessor library for pen.el
# With an emphasis on string transformations, rather than characters.

sn="$(basename "$0")"

stdin_exists() {
    ! [ -t 0 ] && ! test "$(readlink /proc/$$/fd/0)" = /dev/null
}

case "$sn" in
    field|all-caps|caps|uppercase|uc|lc|wrl*|wrla|wrla1|awrl) {
        f="$sn"
    }
    ;;

    repeat-string) {
        f=rs
    }
    ;;

    *) {
        f="$1"
        shift
    }
esac

case "$f" in
    indent) {
        level="$1"; : ${level:="1"}
        # printf -- "%s\n" "$level"
        r="$(zsh -c "printf '\t%.0s' {1..$level}")"

        sed -u "s/^/${r}/"
    }
    ;;

    all-caps|caps|uppercase|uc) {
        tr '[:lower:]' '[:upper:]'
    }
    ;;

    split) {
        delim="$1"
        : ${delim:=" "}

        sed -e "s/./&$delim/g" -e "s/$delim\$//"
    }
    ;;

    join) {
        delim="$1"
        : ${delim:=" "}

        sed -z "s~\n~$delim~g" | sed "s/$delim\$//"
    }
    ;;

    lc) {
        tr '[:upper:]' '[:lower:]'
    }
    ;;

    random-line) {
        awk 'BEGIN { "date +%N" | getline seed; srand(seed) } { l[NR]=$0 } END { print l[int(rand() * NR + 1)] }'
    }
    ;;

    rs|repeat-string) {
        count="$1"
        shift

        : ${count:="1"}

        if stdin_exists; then
            IFS= read -rd '' input < <(cat /dev/stdin)
        else
            input="$1"
        fi

        for (( i = 0; i < count; i++ )); do
            printf -- "%s" "$input"
        done
    }
    ;;

    capfirst) {
        sed 's/[a-zA-Z]/\u&/'
    }
    ;;

    capveryfirst) {
        sed -z 's/[a-zA-Z]/\u&/'
    }
    ;;

    capsent|capitalize-sentences) {
        sed 's/[a-z]\+/\u&/'
    }
    ;;

    cap|capitalize) {
        sed 's/[^ _-]*/\u&/g'
    }
    ;;

    rl|repeat-lines) {
        n="$1"; : ${n:="1"}

        awk 1 | awk '{while (c++<'$n') printf $0}'
    }
    ;;

    q|quote) {
        q
    }
    ;;

    lf|last_field) {
        awk '{print $NF}'
    }
    ;;

    field|col|column) {
        delim='[ \t\n]+'

        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -d) {
                delim="$2"
                shift
                shift
            }
            ;;

            *) break;
        esac; done

        field="$1"
        awk -F "$delim" '{print $'$field'}'
    }
    ;;

    sort-anum|sort-alphanumeric) {
        sort -b -d
    }
    ;;

    uniq) {
        awk '!seen[$0] {print} {++seen[$0]}'
    }
    ;;

    dedup) { # without reordering / sorting
        awk '{print(NR"\t"$0)}' | sort -t$'\t' -k2,2 | uniq -u --skip-fields 1 | sort -k1,1 -t$'\t' | cut -f2 -d$'\t'
    }
    ;;

    rf|remove_field) {
        field="$1"
        ofs=" \t "
        awk -F' *\t *' -v myofs="$ofs" 'BEGIN{OFS=myofs}{$'$field' = ""; print $0}'
    }
    ;;

    # onelineify and unonelineify are not entirely reversible. They're just meant for prompt design
    onelineify) {
        sed -z 's/\n/\\n/g'
    }
    ;;

    unonelineify) {
        sed -z 's/\\n/\n/g'
    }
    ;;

    # These are more reversible
    onelineify-safe) {
        pen-encode-string | sed -z 's/\n/\\n/g'
    }
    ;;

    unonelineify-safe) {
        sed -z 's/\\n/\n/g' | pen-decode-string
    }
    ;;

    commalist2list) {
        sed -z -e "s/^\\s*//" -e "s/\\s*$//" |
        sed -z -e "s/, /\\n/g" -e "s/,$//" |
            uniqnosort
    }
    ;;

    list2args) {
        sed -e 's/^/"/' -e 's/$/"/' |
        pen-str join ' '
    }
    ;;

    remove-trailing-whitespace) {
        sed -z -e "s/\s*\$//" -e "s/\n*\$//"
    }
    ;;
    
    generic-interpreter-tidy-result) {
        pen-str remove-trailing-whitespace | { awk 1; echo -n "Input: "; }
    }
    ;;

    ruby-gen-next-user-prompt) {
        IFS= read -rd '' in < <(cat | tee /tmp/ruby-gen-next-user-prompt);typeset -p in &>/dev/null

        prompt_number="$(printf -- "%s" "$in" | awk 1 | tac | sed -n "/^2.7.0 :/{s/^2.7.0 :\\([0-9]*\\).*/\\1/p;q}")"
        new_prompt_number="$(printf "%03d" $(( prompt_number )))"

        printf -- "%s" "$in" | awk 1 | sed '$d'
        echo -n "2.7.0 :$new_prompt_number > "
    }
    ;;

    python-gen-next-user-prompt) {
        IFS= read -rd '' in < <(cat | tee /tmp/python-gen-next-user-prompt);typeset -p in &>/dev/null

        prompt_number="$(printf -- "%s" "$in" | awk 1 | tac | sed -n "/^Out\\[/{s/^Out\\[\\([0-9]*\\)\\]:.*/\\1/p;q}")"
        new_prompt_number="$(( prompt_number + 1 ))"

        printf -- "%s" "$in" | awk 1
        echo -n "In [$new_prompt_number]: "
    }
    ;;

    has-starting-specified-whitespace) {
        ws="$1"
        sed -n -z "/^$(pen-sqne "$ws")/p" | grep -qP .
    }
    ;;

    if-starts-with-whitespace) {
        ws="$1"
        sed -n -z "/^$(pen-sqne "$ws")/p"
    }
    ;;

    remove-starting-specified-whitespace) {
        ws="$1"
        sed -z "s/^$(pen-sqne "$ws")//"
    }
    ;;

    newline-if-empty) {
        IFS= read -rd '' in < <(cat);typeset -p in &>/dev/null
        if test -z "$in"; then
            echo
        else
            printf -- "%s" "$in"
        fi
    }
    ;;

    remove-starting-and-trailing-whitespace) {
        sed -e 's/^\s*//' -e 's/\s*$//'
    }
    ;;

    tidy-prose-input) {
        pen-str join ' ' |
            pen-str remove-starting-and-trailing-whitespace |
            sed 's/ \+/ /g'
    }
    ;;

    maybe-delete-last-line) {
        IFS= read -rd '' in < <(cat);typeset -p in &>/dev/null
        lines="$(printf -- "%s" "$in" | wc -l)"
        if test "$lines" -gt 1; then
            printf -- "%s" "$in" | sed '$d'
        else
            printf -- "%s" "$in"
        fi
    }
    ;;

    remove-leading-and-trailing-newlines) {
        sed -e :a -e '/./,$!d;/^\n*$/{$d;N;};/\n$/ba'
    }
    ;;

    shell-commentify) {
        pen-str tidy-prose-input | sed "s/\\.\$//" | pen-wrap 50 | sed "s/^/# /"
    }
    ;;

    wrap) {
        width="$1"
        : "${width:="80"}"

        pen-c strip-unicode |
            sed 's/^\(\s\+\)//' |
            pen-str join ' ' |
            sed 's/ \+/ /g' |
            wrlp -E "pen-wrap $width; echo" |
            sed 's/^\s\+$//' |
            sed "s/\s\+/ /g" |
            sed '${/^$/d;}'
    }
    ;;

    nl) {
        # nl | sed 's/^\s*\([0-9]*\)	/\1: /'
        q -fl | nl | sed 's/^\s*//'
    }
    ;;

    *)
esac
