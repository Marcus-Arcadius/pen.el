#!/bin/bash

# TODO Add ability to share a file or directory with the host
# docker run --rm -v "$(pwd):/$(pwd | slugify)" -w "/$(pwd | slugify)" -ti --entrypoint= semiosis/pen.el:latest ./run.sh  

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -tty|-nw) {
        use_tty=y
        shift
    }
    ;;

    *) break;
esac; done

cmd() {
    for var in "$@"
    do
        printf "'%s' " "$(printf %s "$var" | sed "s/'/'\\\\''/g")";
    done | sed 's/ $//'
}

cmd-nice() {
    for var in "$@"
    do
        printf '"%s" ' "$(printf %s "$var" | sed 's/"/\\"/g')";
    done | sed 's/ $//'
}

sn="$(basename "$0")"
bn="$(basename "$0")"

if test "$sn" = pen && test "$#" -eq 0 && test -n "$(docker ps --filter "name=pen" | sed 1d)"; then
    sn=penc
fi

stdin_exists() {
    ! [ -t 0 ] && ! test "$(readlink /proc/$$/fd/0)" = /dev/null
}

case "$sn" in
    pen) {
        if printf -- "%s\n" "$1" | grep -q -P '^pf-'; then
            pfname="$1"
            shift

            use_tty=y

            if stdin_exists; then
                set -- "$(cat)" "$@"
            fi

            CMD="$(cmd-nice "$@")"
            set -- -e "(pen-list2str (pen-single-generation ($pfname $CMD :no-select-result t)))"
            HAS_TTY=n
            batch=y
            docker_cmd=exec
            remote_cmd=./.emacs.d/pen.el/scripts/eval.sh
        fi
    }
    ;;

    penc) {
        set -- -c "$@"
    }
    ;;

    pene) {
        set -- -e "$@"
    }
    ;;

    penl) {
        set -- -e '(pen-list2str pen-prompt-functions)'
    }
    ;;

    penh) {
        set -- -e "(helpful--signature '$1)"
    }
    ;;

    penq) {
        set -- -e "(kill-emacs)"
    }
    ;;

    penz) {
        set -- -e '(pen-list2str pen-prompt-functions)' | fzf
    }
    ;;

    *) {
        if stdin_exists; then
            set -- "$(cat)" "$@"
        fi

        CMD="$(cmd-nice "$@")"
        set -- -e "(pen-list2str (pen-single-generation ($sn $CMD :no-select-result t)))"
        HAS_TTY=n
        batch=y
        docker_cmd=exec
        remote_cmd=./.emacs.d/pen.el/scripts/eval.sh
    }
    ;;
esac

: "${docker_cmd:="run"}"
remote_cmd=./run.sh

is_tty() { [ -t 1 ]; }

if is_tty; then
    HAS_TTY=y
fi

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -c) {
        batch=y
        docker_cmd=exec
        remote_cmd=./.emacs.d/pen.el/scripts/newframe.sh
        shift
    }
    ;;

    -e) {
        HAS_TTY=n
        batch=y
        docker_cmd=exec
        remote_cmd=./.emacs.d/pen.el/scripts/eval.sh
        shift
    }
    ;;

    *) break;
esac; done

yn () {
    y_chars="Yy"
    n_chars="Nn"
    while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
        -N|-carefully) {
            allowed_re="^[YN]$"
            shift
        }
        ;;

        -y|-y-chars) {
            y_chars="$2"
            shift
            shift
        }
        ;;

        -n|-n-chars) {
            n_chars="$2"
            shift
            shift
        }
        ;;

        *) break;
    esac; done

    allowed_re="^[${y_chars}/${n_chars}]$"

    message="$@"

    : ${message:="Are you sure?"}

    exec 1>&2

    echo
    message="$(printf -- "%s" "$message")"
    echo -e " $message"
    echo

    allowed_re="$(printf -- "%s" "$allowed_re")"
    allowed_re_color="$(printf -- "%s" "$allowed_re")"

    if test "$YN_DEFAULT" = "y"; then
        echo y
        exit 0
    fi

    if test "$YN_DEFAULT" = "n"; then
        echo n
        exit 1
    fi

    while :; do
        read -p " $allowed_re_color: " -n 1 -r
        echo
        [[ $REPLY =~ $allowed_re ]] && break
    done
    echo

    [[ $REPLY =~ ^[$y_chars]$ ]]
}

vanilla=
use_pen_config=y

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -Q) {
        vanilla=y
        use_pen_config=n
        shift
    }
    ;;

    -q) {
        vanilla=y
        use_pen_config=y
        shift
    }
    ;;

    *) break;
esac; done

if ! test "$vanilla" = "y"; then
    test -d "$MYGIT/semiosis/prompts" && : "${PROMPTS_DIR:="$MYGIT/semiosis/prompts"}"
    test -d "prompts" && : "${PROMPTS_DIR:="prompts"}"
    # : "${PROMPTS_DIR:="$(read -ep "PROMPTS_DIR (leave empty to use docker): ")"}"

    test -d "$MYGIT/semiosis/pen.el" && : "${PENEL_DIR:="$MYGIT/semiosis/pen.el"}"
    test -d "pen.el" && : "${PENEL_DIR:="pen.el"}"
    # : "${PENEL_DIR:="$(read -ep "PENEL_DIR (leave empty to use docker): ")"}"

    test -d "$MYGIT/semiosis/openai-api.el" && : "${OPENAI_API_EL_DIR:="$MYGIT/semiosis/openai-api.el"}"
    test -d "openai-api.el" && : "${OPENAI_API_EL_DIR:="openai-api.el"}"
    # : "${OPENAI_API_EL_DIR:="$(read -ep "OPENAI_API_EL_DIR (leave empty to use docker): ")"}"

    # yn "Pull docker image?" && docker pull semiosis/pen.el:latest

    # set -v
    if ! test "$batch" = "y"; then
        yn "Pull docker image?" && (
            echo docker pull semiosis/pen.el:latest
            docker pull semiosis/pen.el:latest
        )
    fi

    if ! test "$batch" = "y"; then
        if test -d "$PROMPTS_DIR"; then
            yn "Pull prompts repo?" && (
                cd "$PROMPTS_DIR"
                git pull origin master
            )
        else
            yn "Clone prompts repo here?" && (
                git clone "http://github.com/semiosis/prompts"
            )
        fi
    fi

    test -d "prompts" && : "${PROMPTS_DIR:="prompts"}"

    if ! test "$batch" = "y"; then
        test -d "$PENEL_DIR" && yn "Pull pen.el repo?" && (
            cd "$PENEL_DIR"
            git pull origin master
        )
    fi

    if test -d "$PROMPTS_DIR"; then
        PROMPTS_DIR="$(realpath "$PROMPTS_DIR")"
    fi

fi

if test "$use_pen_config" = "y"; then
    if ! test "$batch" = "y"; then
        if ! test -d "$HOME/.pen" && yn "Create ~/.pen on host (store API keys and generations)?"; then
            mkdir -p "$HOME/.pen"
        fi
    fi

    test -d "$HOME/.pen" && : "${PEN_CONFIG_DIR:="$HOME/.pen"}"

    if ! test "$batch" = "y"; then
        : "${PEN_CONFIG_DIR:="$(read -ep "PEN_CONFIG_DIR (leave empty to use docker): ")"}"
    fi

    if test -d "$PEN_CONFIG_DIR"; then
        PEN_CONFIG_DIR="$(realpath "$PEN_CONFIG_DIR")"
    fi
fi

rp="$(realpath "$0")"

case "$docker_cmd" in
    run) {
IFS= read -r -d '' shcode <<HEREDOC
    # --user "$(id -u):$(id -g)"
    docker "$docker_cmd" \
        $(test -n "$OPENAI_API_KEY" && printf -- "%s " -e "OPENAI_API_KEY:$OPENAI_API_KEY" ) \
        $(test -n "$PEN_CONFIG_DIR" && printf -- "%s " -v "$PEN_CONFIG_DIR:/root/.pen" ) \
        $(test -n "$PROMPTS_DIR" && printf -- "%s " -v "$PROMPTS_DIR:/root/.emacs.d/host/prompts" ) \
        $(test -n "$PENEL_DIR" && printf -- "%s " -v "$PENEL_DIR:/root/.emacs.d/host/pen.el" ) \
        $(test -n "$OPENAI_API_EL_DIR" && printf -- "%s " -v "$OPENAI_API_EL_DIR:/root/.emacs.d/host/openai-api.el" ) \
        $(test "$HAS_TTY" = y && printf -- "%s " -ti ) \
        --entrypoint= --name=pen semiosis/pen.el:latest "$remote_cmd" "$@"
HEREDOC
    }
    ;;

    exec) {
        evalcommand="$(cmd "$(cmd eval "$(cmd "$remote_cmd" "$@")")")"
IFS= read -r -d '' shcode <<HEREDOC
    # --user "$(id -u):$(id -g)"
    docker "$docker_cmd" \
        $(test "$HAS_TTY" = y && printf -- "%s " -ti ) \
        pen bash -c $evalcommand
HEREDOC
    }
    ;;

    *)
esac

hn="$(hostname)"
xtbin="$(command -v xterm)"

case "$hn" in
    mele) {
        xtbin=/usr/bin/xterm
    }
    ;;

    *)
esac

if test "$use_tty" = y; then
    eval "$shcode"
elif ( test "$sn" = penc || test "$sn" = pen ) && ! test "$use_tty" = y && test -n "$DISPLAY" && command -v xterm &>/dev/null; then
    if ! test "$use_tty" = n; then
        "$xtbin" -fs 16 -e "$shcode" & disown
    else
        eval "$shcode"
    fi
else
    eval "$shcode"
fi
