#!/bin/bash
# set -vx

# Pen
# Version 2.0, bash

# If mac
# --env="DISPLAY=host.docker.internal:0"

# echo "shutdown computer" | penf -u pf-nlsh/2 "Windows 95" {}

# Invocations:
# - pen/penx
# - penf
# - ii
# - lg/lgx/looking-glass
# - cosm/paracosm
# - nlsh
# - apo/apostrophe

pen_version=2.0

pen_image=semiosis/pen.el:latest
pen_container_name=pen

sn="$(basename "$0")"
bn="$sn"
rp="$(realpath "$bn")"

export PS4='+	"$(basename $0)"	${LINENO}	 '

inside-docker-p() {
    test -f /.dockerenv
}

unset PEN_USE_GUI

drunning=
docker-running-p() {
    test "$drunning" = y || test -n "$(docker ps --filter "name=${pen_container_name}$" | sed 1d)"
    ret="$?"
    if test "$ret" -eq 0; then
        drunning=y
    else
        false
    fi
    # if test "$drunning" = y || docker exec "${pen_container_name}" true; then
}

stdin_exists() {
    ! [ -t 0 ] && ! test "$(readlink /proc/$$/fd/0)" = /dev/null
}

test_deps() {
    (
    set -xv
    command -v realpath && \
        command -v basename
    ) 2>&1
}

ensure_dependencies() {
    ds="$(test_deps)"
    code="$?"
    if ! test "$code" = 0; then
        echo "Please ensure dependencies are installed"

        for s in realpath basename; do
            echo "https://command-not-found.com/$s"
        done

        exit "$?"
    fi
}

ensure_dependencies

yn () {
    if test "$yes" = "y"; then
        return 0
    fi

    if test "$no" = "y"; then
        return 1
    fi

    y_chars="Yy"
    n_chars="Nn"
    while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
        -N|-carefully) {
            allowed_re="^[YN]$"
            shift
        }
        ;;

        -y|-y-chars) {
            y_chars="$2"
            shift
            shift
        }
        ;;

        -n|-n-chars) {
            n_chars="$2"
            shift
            shift
        }
        ;;

        *) break;
    esac; done

    allowed_re="^[${y_chars}/${n_chars}]$"

    message="$@"

    : ${message:="Are you sure?"}

    exec 1>&2

    echo
    message="$(printf -- "%s" "$message")"
    echo -e " $message"
    echo

    allowed_re="$(printf -- "%s" "$allowed_re")"
    allowed_re_color="$(printf -- "%s" "$allowed_re")"

    if test "$YN_DEFAULT" = "y"; then
        echo y
        exit 0
    fi

    if test "$YN_DEFAULT" = "n"; then
        echo n
        exit 1
    fi

    while :; do
        read -p " $allowed_re_color: " -n 1 -r
        echo
        [[ $REPLY =~ $allowed_re ]] && break
    done
    echo

    [[ $REPLY =~ ^[$y_chars]$ ]]
}

{
stty stop undef; stty start undef
} 2>/dev/null

# TODO Add ability to share a file or entire directory with the host -- this would only work for docker run though
# But file sharing could work with the client if I use a hardlink to the ~/.pen/documents directory
# docker run --rm -v "$(pwd):/$(pwd | slugify)" -w "/$(pwd | slugify)" -ti --entrypoint= $pen_image ./run.sh

IFS= read -r -d '' info_txt <<HEREDOC
Pen is under continual development.
If something is broken, try pulling everything.
If it's still broken, try again in a day.
If it's still broken, please make an issue on GitHub.
Or report to mullikine on Discord: https://discord.gg/JwKGbAdNHR
https://github.com/semiosis/pen.el/
HEREDOC

is_tty() { [ -t 1 ]; }

if is_tty; then
    HAS_TTY=y
else
    HAS_TTY=n
    batch=y
fi

: "${PEN_USE_GUI:="y"}"
: "${share_x:="y"}"

docker() {
    if test "$DEBUG_ABORT" = "y"; then
        cmd "$@" | awk 1
        exit "$?"
    fi

    export PEN_NO_TM

    if inside-docker-p; then
        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            bash) break;;
            run.sh|/root/run.sh|./run.sh) {
                shift
                set -- run.sh "$@"
                break
            };;
            newframe.sh|/root/newframe.sh|./newframe.sh) {
                shift
                set -- newframe.sh "$@"
                break
            };;
            eval.sh|/root/eval.sh|./eval.sh) {
                shift
                set -- eval.sh "$@"
                break
            };;
            *) shift;;
        esac; done

        if test "$USE_NVC" = "y"; then
            set -- nvc "$@"
        fi

        # tmux new-window "$@" || tmux new-session "$@"
        "$@"
    else
        command docker "$@"
    fi
}

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    sh) {
        start_shell=y
        shift
    }
    ;;

    tm) {
        start_shell=y
        shift
        set -- tmux "$@"
    }
    ;;

    lsp) {
        shift
        set -- sh pen-lsp "$@"
        start_shell=y
    }
    ;;

    tma) {
        start_shell=y
        shift
        set -- "$@" eval "tmux attach || tmux || zsh"
    }
    ;;

    -tty|-nw|-t) {
        PEN_USE_GUI=n
        shift
    }
    ;;

    -notm) {
        export PEN_NO_TM=y
        shift
    }
    ;;

    -frametype) {
        export FRAME_TYPE="$2"
        shift
        shift
    }
    ;;

    -nn) {
        no=y
        show_banner=n
        shift
    }
    ;;

    -n) {
        no=y
        shift
    }
    ;;

    --parallel|--pool) {
        export USE_POOL=y
        shift
    }
    ;;

    --temp) {
        temperature="$2"
        shift
        shift
    }
    ;;

    --engine) {
        PEN_ENGINE="$2"
        shift
        shift
    }
    ;;

    --citation) {
        pen-citation
        exit "$?"
        shift
        shift
    }
    ;;

    -nv) {
        USE_NVC=y
        shift
    }
    ;;

    -y) {
        yes=y
        shift
    }
    ;;

    -all|-a) {
        all=y
        shift
    }
    ;;

    -json|-j) {
        output_json=y
        shift
    }
    ;;

    -nojson|-nj) {
        output_json=n
        shift
    }
    ;;

    # Show prompt
    -prompt|-p) {
        prompt=y
        shift
    }
    ;;

    # Show prompt
    -override-prompt|-op) {
        override_prompt="$2"
        shift
        shift
    }
    ;;

    -inject|-i) {
        inject_gen_start="$2"
        shift
        shift
    }
    ;;

    # No generation/query
    -nogen|-n) {
        no_gen=y
        shift
    }
    ;;

    -running-p) {
        docker-running-p
        exit "$?"
    }
    ;;

    -X) {
        share_x=y
        shift
    }
    ;;

    -noX|-safe) {
        PEN_USE_GUI=n
        share_x=n
        shift
    }
    ;;

    -nogui|-tty) {
        PEN_USE_GUI=n
        shift
    }
    ;;

    -big) {
        pen_image=semiosis/pen.el:big
        pen_container_name=penbig
        shift
    }
    ;;

    -gui) {
        PEN_USE_GUI=y
        share_x=y
        shift
    }
    ;;

    -d) {
        DEBUG=y
        shift
    }
    ;;

    -u) {
        UPDATE=y
        PEN_UPDATE=t
        shift
    }
    ;;

    --pen-update|--do-update) {
        PEN_UPDATE="$2"
        shift
        shift
    }
    ;;

    --prompt-hist-id) {
        PROMPT_HIST_ID="$2"
        shift
        shift
    }
    ;;

    -Q) {
        vanilla=y
        use_pen_config=n
        shift
    }
    ;;

    -q) {
        vanilla=y
        use_pen_config=y
        shift
    }
    ;;

    *) break;
esac; done

if test "$PEN_UPDATE" = "y"; then
    PEN_UPDATE=t
fi

if test "$UPDATE" = "y"; then
    PEN_UPDATE=t
else
    : "${PEN_UPDATE:="nil"}"
fi

if test "$PEN_UPDATE" = "t"; then
    UPDATE=y
fi

case "$FRAME_TYPE" in
    tty) {
        PEN_USE_GUI=n
    }
    ;;

    gui) {
        PEN_USE_GUI=y
    }
    ;;

    *)
esac

if test -n "$PROMPT_HIST_ID"; then
    PROMPT_HIST_ID="\"$PROMPT_HIST_ID\""
else
    PROMPT_HIST_ID=nil
fi

if ! test -n "$PEN_TEMPERATURE"; then
    PEN_TEMPERATURE=nil
fi

if ! test -n "$PEN_ENGINE"; then
    PEN_ENGINE=nil
fi

if test "$PEN_ENGINE" = "nil"; then
    PEN_ENGINE_Q=nil
else
    PEN_ENGINE_Q="\"$PEN_ENGINE\""
fi

export USE_NVC

if stdin_exists && \
    ! printf -- "%s\n" "$1" | grep -q -P '^pf-' && \
    ! test "$sn" = penu && \
    ! test "$sn" = pena && \
    ! test "$sn" = penj && \
    ! test "$sn" = penf; then

    fp="$(pen-tf txt)"

    exec 0<&1

    if test "$sn" = pen && test "$#" -eq 0 && { inside-docker-p || docker-running-p; }; then
        sn=penc
    fi

    set -- "$@" "$fp"
fi

if test "$sn" = penx; then
    if inside-docker-p || docker-running-p; then
        sn=penc
    else
        sn=pen
    fi

    PEN_USE_GUI=y
    share_x=y
fi

if test "$sn" = pent; then
    if inside-docker-p || docker-running-p; then
        sn=penc
        HAS_TTY=y
        show_banner=n
        PEN_USE_GUI=n
    fi
fi

if test "$sn" = lgx; then
    sn=lg

    PEN_USE_GUI=y
    share_x=y
fi

if ! test "$share_x" = "y"; then
    export DISPLAY=
fi

ensure_pen_running() {
    if ! inside-docker-p && ! docker-running-p; then
        echo Starting Pen. Please wait... 1>&2

        # Start pen in background and wait, or start and detach when done
        # How can I detach it when done loading?
        # Maybe the only  way is to ensure that pen -n always starts pen with no interruptions.
        # TODO Ensure that pen.el still starts, even with empty ~/.pen
        ( unbuffer pen -nw -n &>/dev/null; ) & disown

        while !  docker exec "${pen_container_name}" true &>/dev/null; do
            sleep 1
        done
    fi
}

if test "$start_shell" = "y"; then
    export DISPLAY=
    # nvt

    : ${CMD:="$(cmd "$@")"}
    : "${CMD:="/bin/bash || /bin/zsh || sh"}"

    if ! inside-docker-p && ! docker-running-p; then
        # Start pen in background and wait
        ensure_pen_running
    fi

    docker exec -it "$pen_container_name" 'sh' '-c' ". /root/.emacs.d/pen.el/scripts/setup-term.sh; $CMD"
    exit "$?"
fi

cmd() {
    for var in "$@"
    do
        printf "'%s' " "$(printf %s "$var" | sed "s/'/'\\\\''/g")";
    done | sed 's/ $//'
}

cmd-onelineify-safe() {
    for var in "$@"
    do
        printf "'%s' " "$(printf %s "$var" | pen-str onelineify-safe)";
    done | sed 's/ $//'
}

cmd-unonelineify-safe() {
    for var in "$@"
    do
        printf "'%s' " "$(printf %s "$var" | pen-str unonelineify-safe)";
    done | sed 's/ $//'
}

cmd-nice() {
    # TODO Check for builtin
    # cmd-nice-jq

    for var in "$@"
    do
        printf '"%s" ' "$(printf %s "$var" | sed 's/\(\\*\)"/\1\1\\"/g')";
        # printf '"%s" ' "$(printf %s "$var" | sed 's/\(\\\)\([^"]\|$\)/\1\1\2/g' | sed 's/\(\\*\)"/\1\1\\"/g')";
    done | sed 's/ $//'
}

cmd-nice-with-bs() {
    for var in "$@"
    do
        # printf '"%s" ' "$(printf %s "$var" | sed 's/\(\\*\)"/\1\1\\"/g')";
        printf '"%s" ' "$(printf %s "$var" | sed 's/\(\\\)\([^"]\|$\)/\1\1\2/g' | sed 's/\(\\*\)"/\1\1\\"/g')";
    done | sed 's/ $//'
}

vanilla=
use_pen_config=y

if test "$use_pen_config" = "y"; then
    if ! test "$batch" = "y"; then
        if ! test -d "$HOME/.pen" && yn "Create ~/.pen on host (store API keys and generations)?"; then
            mkdir -p "$HOME/.pen"
        fi
    fi

    test -d "$HOME/.pen" && : "${PEN_CONFIG_DIR:="$HOME/.pen"}"

    if ! test "$batch" = "y"; then
        : "${PEN_CONFIG_DIR:="$(read -ep "PEN_CONFIG_DIR (leave empty to use docker): ")"}"
    fi

    if test -d "$PEN_CONFIG_DIR"; then
        PEN_CONFIG_DIR="$(realpath "$PEN_CONFIG_DIR")"
    fi
fi

if test -d "$PEN_CONFIG_DIR"; then
    mkdir -p "$PEN_CONFIG_DIR/documents"
fi

if { test "$sn" = pen || test "$sn" = penc || test "$sn" = penv || test "$sn" = pent; } && \
    test "$#" -eq 1 && \
    test -n "$1" && \
    test -f "$1" && \
    test -d "$PEN_CONFIG_DIR/documents"; then

    rp="$(realpath "$1")"
    bn="$(basename "$rp")"

    export NO_QUIT_DAEMONS=y

    if ! inside-docker-p; then
        ln -f "$rp" "$PEN_CONFIG_DIR/documents/$bn"
        shift
        set -- "/root/.pen/documents/$bn" "$@"

        # This is ideal, but requires more work
        # set -- -e "(find-file $(cmd-nice "/root/.pen/documents/$bn"))"
    fi

    if test "$USE_POOL" = "y"; then
        remote_cmd=newframe.sh
        # remote_cmd=/root/.emacs.d/host/pen.el/scripts/newframe.sh
    fi
fi

if test "$sn" = pen && test "$1" = -e && docker-running-p; then
    shift
    sn=pene
fi

if test "$sn" = pen && test "$#" -eq 0 && { inside-docker-p || docker-running-p; }; then
    sn=penc
fi

stdin_exists() {
    ! [ -t 0 ] && ! test "$(readlink /proc/$$/fd/0)" = /dev/null
}

if test "$sn" = pena; then
    sn=penf
    all=y
    : "${output_json:="y"}"
elif test "$sn" = penj; then
    sn=penf
    : "${output_json:="y"}"
fi

case "$sn" in
    penf) {
        fun="$1"

        if stdin_exists; then
            arity="$(( $# ))"
        else
            arity="$(( $# - 1 ))"
        fi

        if ! printf -- "%s\n" "$fun" | grep -q -P '/[0-9]+$'; then
            fun="$(penl 2>&1 | grep -P "^(pf-)?${fun}/$arity$")"
        fi

        if ! printf -- "%s\n" "$fun" | grep -q -P "/${arity}$"; then
            sn=penh
            penl_strip_pf=y
        elif ! stdin_exists; then
            if test "$#" -eq 0; then
                sn=penl
                penl_strip_pf=y
            elif test -z "$fun" && test "$#" -ge 1 && ! printf -- "%s\n" "$1" | grep -Pq "/$(( $# - 1 ))\$"; then
                sn=penh
                penl_strip_pf=y
            fi
        fi
    }
    ;;

    *)
esac

case "$sn" in
    pen|penf) {
        if test "$sn" = penf; then
            if test -n "$fun"; then
                shift
                set -- "$fun" "$@"
            fi
            if test -n "$1" && ! printf -- "%s\n" "$1" | grep -q -P '^pf-'; then
                fun="pf-$1"
                shift
            else
                fun="$1"
                shift
            fi
            sn="pen"
        else
            fun="$1"
            shift
        fi

        if printf -- "%s\n" "$fun" | grep -q -P '^pf-'; then
            show_banner=n

            pfname="$fun"

            if stdin_exists; then
                # This has issues
                # in="$(cat | qne)"

                # So do I escape or not? Yes. Also remove final whitespace
                # To test, ensure this works:
                # echo -n "Once upon " | penf --pool pf-generic-completion-50-tokens/1
                in="$(cat | sed -z 's/\s\+$//' | pen-limit-chars)"

                if test "$1" = {}; then
                    shift

                    # This has issues
                    set -- "$in" "$@"
                elif test "$#" -gt 1; then
                    i=1
                    found=
                    for var in "$@"
                    do
                        h="$((i - 1))"
                        j="$((i + 2))"
                        if test "$var" = "{}"; then
                            set -- "${@:1:$h}" "$in" "${@:j}"
                            found=y
                        fi
                        ((i++))
                    done
                    if ! test "$found" = "y"; then
                        # set -- "$@" "$in"
                        set -- "$in" "$@"
                    fi
                else
                    set -- "$in" "$@"
                fi
            fi

            if ! printf -- "%s\n" "$pfname" | grep -q -P '/[0-9]*'; then
                pfname="$pfname/$#"
            else
                # If the arity is specified, then take any extras and use as the variadic_arg

                arity="$(printf -- "%s" "$pfname" | cut -d / -f 2)"
                transultimate_pos="$((arity + 1))"

                variadic_arg_arr=("${@:transultimate_pos}")
                variadic_arg="$(cmd-nice "${variadic_arg_arr[@]}")"

                # Only keep the regular vars
                set -- "${@:1:$arity}"
            fi

            if test -n "$variadic_arg"; then
                variadic_arg="'($variadic_arg)"
            else
                variadic_arg=nil
            fi

            CMD="$(cmd-nice "$@")"

            if test "$prompt" = "y"; then
                include_prompt=t
            else
                include_prompt=nil
            fi

            if test "$no_gen" = "y"; then
                no_gen=t
            else
                no_gen=nil
            fi

            if test -n "$inject_gen_start"; then
                inject_gen_start="$(cmd-nice "$inject_gen_start")"
            else
                inject_gen_start="nil"
            fi

            if test -n "$override_prompt"; then
                override_prompt="$(cmd-nice "$override_prompt")"
            else
                override_prompt="nil"
            fi

            # if test "$DEBUG" = "y"; then
            #     echo "(json-encode-list (pen-batch (pen-update ($pfname $CMD :no-select-result t :include-prompt $include_prompt :no-gen $no_gen :variadic-var $variadic_arg))))" | tv &>/dev/null
            # fi

            if test "$output_json" = "y"; then
                output_fn=json-encode-list
            else
                output_fn=pen-list2str
            fi

            if test "$all" = "y"; then
                ncompletions_limiter_fn="mapcar 'identity"
            else
                ncompletions_limiter_fn=pen-single-generation
            fi

            set -- -e "($output_fn (pen-batch ($ncompletions_limiter_fn (pen-force ((do-pen-update $PEN_UPDATE) (pen-force-engine $PEN_ENGINE_Q) (force-temperature $PEN_TEMPERATURE)) ($pfname $CMD :no-select-result t :prompt-hist-id $PROMPT_HIST_ID :include-prompt $include_prompt :no-gen $no_gen :variadic-var $variadic_arg :override-prompt $override_prompt :inject-gen-start $inject_gen_start)))))"

            HAS_TTY=n
            batch=y
            docker_cmd=exec
            remote_cmd=/root/.emacs.d/host/pen.el/scripts/eval.sh
        else
            # Put it back
            set -- "$fun" "$@"
        fi
    }
    ;;

    pensh) {
        # HAS_TTY=y
        batch=y
        docker_cmd=exec

        firstarg="$1"
        shift

        remote_cmd="$firstarg"
    }
    ;;

    penc) {
        set -- -c "$@"
    }
    ;;

    pene) {
        show_banner=n
        set -- -e "$@"
    }
    ;;

    # pen call ilambda function
    # Example: peni list-programming-languages 5
    # pene "(pps (progn (idefun list-programming-languages)) (list-programming-languages \"5\"))"
    # peni color-of-thing watermelon
    peni) {
        show_banner=n
        sn=pene

        ifunc_name="$1"
        shift

        ARGS="$(cmd-nice-posix "$@")"

        set -- -e "(pps (progn (idefun $ifunc_name) ($ifunc_name $ARGS)))"
    }
    ;;

    # pen call ilambda macro (generate code)
    # (pps (macroexpand (progn (imacro fib-sequence)(fib-sequence 5))))
    penm) {
        show_banner=n
        sn=pene

        imacro_name="$1"
        shift

        ARGS="$(cmd-nice-posix "$@")"

        set -- -e "(pps (progn (imacro $imacro_name) (macroexpand ($imacro_name $ARGS))))"
    }
    ;;

    pent) {
        # This is used to run docker terminal emacs with -e
        # Advanced.
        # Used for ii.
        HAS_TTY=y
        show_banner=n
        PEN_USE_GUI=n
        # export DEBUG_ABORT=y
        # set -- -t -- -e "$@"
    }
    ;;

    pente) {
        # This is used to run docker terminal emacs with -e
        # Advanced.
        # Used for ii.
        HAS_TTY=y
        show_banner=n
        PEN_USE_GUI=n
        export USE_NVC
        # export DEBUG_ABORT=y
        set -- -t -- -e "$@"
    }
    ;;

    penv) {
        export USE_NVC=y
        HAS_TTY=y
        show_banner=n
        PEN_USE_GUI=n
    }
    ;;

    penu) {
        show_banner=n
        UPDATE=y
        set -- -e "$@"
    }
    ;;

    penl) {
        show_banner=n
        set -- -e '(pen-list2str pen-prompt-functions)'
    }
    ;;

    lg|looking-glass) {
        show_banner=y
        set -- -ic "(funcall-interactively 'eww $(cmd-nice "$1"))"
    }
    ;;

    paracosm|cosm) {
        show_banner=y
        HAS_TTY=y
        PEN_USE_GUI=n
        # set -- -ic "(funcall-interactively 'pen-org-brain-switch-brain $(cmd-nice "$1"))"

        set -- -ic "(call-interactively 'pen-org-brain-switch-brain)"
    }
    ;;

    penh) {
        if test -n "$1" && ! printf -- "%s\n" "$1" | grep -q -P '^pf-'; then
            fun="$1"
            shift

            set -- "pf-$fun" "$@"
        fi

        if test -n "$1" && ! printf -- "%s\n" "$1" | grep -q -P '/[0-9]'; then
            if test "$#" -gt 0; then
                fun="$(penl | grep "^$1/" | head -n 1)"
            else
                fun="$(penl | grep "^$1/$#" | head -n 1)"
            fi
        fi

        show_banner=n
        if test "$#" -eq 0; then
            fun="$(penz)"
        else
            fun="$1"
        fi
        set -- -e "(helpful--signature '$fun)"
    }
    ;;

    penq) {
        show_banner=n
        if { ! inside-docker-p; } && docker-running-p; then
            set -- -e "(progn (pen-sn \"pen-shutdown\")(kill-emacs))"
        elif inside-docker-p; then
            pen-shutdown
            killall emacs
        else
            echo Not running. 1>&2
            exit 0
        fi
    }
    ;;

    penz) {
        show_banner=n
        fuzzy=y
        set -- -e '(pen-list2str pen-prompt-functions)'
    }
    ;;

    *) {
        show_banner=n
        if stdin_exists; then
            in="$(cat)"

            if test "$1" = {}; then
                shift

                set -- "$(cat)" "$@"
            elif test "$#" -gt 1; then
                i=1
                for var in "$@"
                do
                    h="$((i - 1))"
                    j="$((i + 2))"
                    if test "$var" = "{}"; then
                        set -- "${@:1:$h}" "$in" "${@:j}"
                    fi
                    ((i++))
                done
            else
                set -- "$in" "$@"
            fi
        fi

        CMD="$(cmd-nice "$@")"

        set -- -e "(pen-list2str (pen-single-generation (pen-force ((do-pen-update $PEN_UPDATE) (pen-force-engine $PEN_ENGINE_Q) (force-temperature $PEN_TEMPERATURE)) ($sn $CMD :no-select-result t :temperature $temperature :prompt-hist-id $PROMPT_HIST_ID))))"
        HAS_TTY=n
        batch=y
        docker_cmd=exec
        remote_cmd=./.emacs.d/pen.el/scripts/eval.sh
    }
    ;;
esac

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    config) {
        shift
        set -- -ic "(call-interactively 'pen-customize)"
    }
    ;;

    *) break;
esac; done

{
if ! test "$show_banner" = n; then
    printf -- "%s\n" "$banner"
    case "$sn" in
        lg*|looking-glass*) {
            looking-glass-logo
        }
        ;;

        ap*) {
            apostrophe-logo
        }
        ;;

        paracosm*|cosm*) {
            paracosm-logo
        }
        ;;

        ii*) {
            ii-logo
        }
        ;;

        nlsh*) {
            nlsh-logo
            echo "Natural Language Shell"
            echo
        }
        ;;

        *) {
            pen-banner.sh
            echo
            echo Version: ${pen_version}, License: GPL-3
            echo
            printf -- "%s\n" "$info_txt"
        }
        ;;
    esac
    echo
fi
} 1>&2

: "${docker_cmd:="run"}"
: "${remote_cmd:="/root/run.sh"}"

opt="$1"
case "$opt" in
    uninstall) {
        set -xv
        sudo rm -irf ~/.pen
    }
    ;;

    *)
esac

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -c) {
        batch=y
        docker_cmd=exec

        shift

        CMD="$(cmd-nice "$@")"
        : ${CMD:="$(cmd-nice "$@")"}

        if inside-docker-p; then
            remote_cmd=newframe.sh
        else
            remote_cmd="/root/.emacs.d/host/pen.el/scripts/newframe.sh"
        fi

        # Shift all so it doesn't do -e here
        # shift "$#"
    }
    ;;

    -ic) {
        batch=y
        docker_cmd=exec
        interactive=y

        shift

        CMD="$(cmd-nice "$@")"
        : ${CMD:="$(cmd-nice "$@")"}

        if inside-docker-p; then
            remote_cmd=newframe.sh
        else
            remote_cmd="/root/.emacs.d/host/pen.el/scripts/newframe.sh"
        fi

        # Shift all so it doesn't do -e here
        # shift "$#"
    }
    ;;

    -e) {
        HAS_TTY=n
        batch=y
        share_x=n
        docker_cmd=exec
        if inside-docker-p; then
            remote_cmd=eval.sh
        else
            remote_cmd="/root/.emacs.d/pen.el/scripts/eval.sh"
        fi
        shift

        if test "$UPDATE" = "y"; then
            last_arg="${@: -1}"
            test "$#" -gt 0 && set -- "${@:1:$(($#-1))}" # shift last arg

            set -- "$@" "(pen-update $last_arg)"
        fi
    }
    ;;

    # This is like pene, has the tty
    -t) {
        batch=y
        share_x=n
        docker_cmd=exec
        shift

        if inside-docker-p; then
            remote_cmd=newframe.sh
        else
            remote_cmd="/root/.emacs.d/pen.el/scripts/newframe.sh"
        fi

        if test "$UPDATE" = "y"; then
            last_arg="${@: -1}"
            test "$#" -gt 0 && set -- "${@:1:$(($#-1))}" # shift last arg

            set -- "$@" "(pen-update $last_arg)"
        fi
    }
    ;;

    --)
        shift
        break
    ;;

    *) break;
esac; done

if ! test "$vanilla" = "y" && ! inside-docker-p && ! docker-running-p; then
    test -n "$MYGIT" && test -d "$MYGIT/semiosis/glossaries" && : "${GLOSSARIES_DIR:="$MYGIT/semiosis/glossaries"}"
    test -d "glossaries" && : "${GLOSSARIES_DIR:="`pwd`/glossaries"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/prompts" && : "${PROMPTS_DIR:="$MYGIT/semiosis/prompts"}"
    test -d "prompts" && : "${PROMPTS_DIR:="`pwd`/prompts"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/engines" && : "${PEN_ENGINES_DIR:="$MYGIT/semiosis/engines"}"
    test -d "engines" && : "${PEN_ENGINES_DIR:="`pwd`/engines"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/pen.el" && : "${PENEL_DIR:="$MYGIT/semiosis/pen.el"}"
    test -d "pen.el" && : "${PENEL_DIR:="`pwd`/pen.el"}"
    # : "${PENEL_DIR:="$(read -ep "PENEL_DIR (leave empty to use docker): ")"}"

    test -n "$MYGIT" && test -d "$MYGIT/semiosis/pen-contrib.el" && : "${CONTRIB_DIR:="$MYGIT/semiosis/pen-contrib.el"}"
    test -d "pen-contrib.el" && : "${CONTRIB_DIR:="`pwd`/pen-contrib.el"}"

    test -d "$MYGIT/semiosis/openai-api.el" && : "${OPENAI_API_EL_DIR:="$MYGIT/semiosis/openai-api.el"}"
    test -d "openai-api.el" && : "${OPENAI_API_EL_DIR:="`pwd`/openai-api.el"}"
    # : "${OPENAI_API_EL_DIR:="$(read -ep "OPENAI_API_EL_DIR (leave empty to use docker): ")"}"

    # yn "Pull docker image?" && docker pull $pen_image

    # set -v
    if ! test "$batch" = "y"; then
        yn "Pull docker image?" && (
            echo docker pull $pen_image
            docker pull $pen_image
        )
    fi

    if ! test "$batch" = "y"; then
        if test -d "$PEN_ENGINES_DIR"; then
            yn "Pull engines repo? (recommended)" && (
                cd "$PEN_ENGINES_DIR"
                git pull origin master
            )
        else
            yn "Clone engines repo here?" && (
                git clone "http://github.com/semiosis/engines"
            )
        fi
    fi

    test -d "engines" && : "${PEN_ENGINES_DIR:="engines"}"

    if ! test "$batch" = "y"; then
        if test -d "$PROMPTS_DIR"; then
            yn "Pull prompts repo? (recommended)" && (
                cd "$PROMPTS_DIR"
                git pull origin master
            )
        else
            yn "Clone prompts repo here?" && (
                git clone "http://github.com/semiosis/prompts"
            )
        fi
    fi

    test -d "prompts" && : "${PROMPTS_DIR:="prompts"}"

    if ! test "$batch" = "y"; then
        test -d "$PENEL_DIR" && yn "Pull pen.el repo? (recommended)" && (
            cd "$PENEL_DIR"
            git pull origin master
        )
    fi

    if ! test "$batch" = "y"; then
        test -d "$CONTRIB_DIR" && yn "Pull pen-contrib.el repo? (recommended)" && (
            cd "$CONTRIB_DIR"
            git pull origin master
        )
    fi

    if test -d "$PROMPTS_DIR"; then
        PROMPTS_DIR="$(realpath "$PROMPTS_DIR")"
    fi

    if test -d "$PEN_ENGINES_DIR"; then
        PEN_ENGINES_DIR="$(realpath "$ENGINES_DIR")"
    fi
fi

# TODO Solve permissions issues with the host ~/.pen directory

# --env "USER=$USER" \
# --env "GROUP=$USER" \
# --env "USER_ID=1000" \
# --env "GROUP_ID=1000" \

if ! test -n "$DISPLAY"; then
    PEN_USE_GUI=n
fi

export PEN_USE_GUI

if test "$docker_cmd" = run && docker-running-p && ! inside-docker-p; then
    docker_cmd=exec
fi

if ! inside-docker-p && ! docker-running-p; then
    if printf -- "%s\n" "$INSIDE_EMACS" | grep -q comint &>/dev/null; then
        unbuffer pen &>/dev/null & disown
    fi

    if test "$docker_cmd" = exec; then
        set -- -e "$@"
    fi
    docker_cmd=run
    remote_cmd="/root/run.sh"
fi

case "$docker_cmd" in
    run) {

    if test -n "$DISPLAY"; then
        cmd-nice xhost + | awk 1 1>&2
        xhost +

        echo
        echo If this fails, try running pen with -noX
        echo " pen -noX"
        echo
    fi

CMD="$(cmd "$@")"
: ${CMD:="$(cmd "$@")"}

: "${USER:="$(whoami)"}"

IFS= read -r -d '' shcode <<HEREDOC
    # --user "$(id -u):$(id -g)"

    # Double ensure it's removed
    docker container rm "$pen_container_name" &>/dev/null

    docker "$docker_cmd" \
        $(test "$docker_cmd" = run && printf -- "%s " --rm ) \
        $(test -n "$OPENAI_API_KEY" && printf -- "%s " -e "OPENAI_API_KEY:$OPENAI_API_KEY" ) \
        $(test -n "$PEN_CONFIG_DIR" && printf -- "%s " -v "$PEN_CONFIG_DIR:/root/.pen" ) \
        $(test -n "$PROMPTS_DIR" && printf -- "%s " -v "$PROMPTS_DIR:/root/.emacs.d/host/prompts" ) \
        $(test -n "$PEN_ENGINES_DIR" && printf -- "%s " -v "$ENGINES_DIR:/root/.emacs.d/host/engines" ) \
        $(test -n "$PENEL_DIR" && printf -- "%s " -v "$PENEL_DIR:/root/.emacs.d/host/pen.el" ) \
        $(test -n "$CONTRIB_DIR" && printf -- "%s " -v "$CONTRIB_DIR:/root/.emacs.d/host/pen-contrib.el" ) \
        $(test -n "$GLOSSARIES_DIR" && printf -- "%s " -v "$GLOSSARIES_DIR:/root/.emacs.d/host/glossaries" ) \
        $(test -n "$OPENAI_API_EL_DIR" && printf -- "%s " -v "$OPENAI_API_EL_DIR:/root/.emacs.d/host/openai-api.el" ) \
        $(test "$HAS_TTY" = y && printf -- "%s " -ti ) \
        --env PEN_USE_GUI \
        --env PEN_NO_TM \
        --env NO_QUIT_DAEMONS \
        --env USE_NVC \
        --env TERM \
        --env USE_NVC \
        $(if test -n "$DISPLAY"; then
        cmd --privileged \
        --env COLORFGBG \
        -e DISPLAY=${DISPLAY} \
        --env EMAIL \
        --env "PEN_USER=$USER" \
        --env GIT_AUTHOR_EMAIL \
        --env GIT_AUTHOR_NAME \
        --env GIT_COMMITTER_EMAIL \
        --env GIT_COMMITTER_NAME \
        --env SSH_AUTH_SOCK \
        --env "TIMEZONE=UTC" \
        --env "VIDEO_GROUP_ID=44" \
        -v /dev/dri:/dev/dri \
        -v /dev/shm:/dev/shm \
        -v /tmp/.X11-unix:/tmp/.X11-unix \
        "--cap-add=SYS_PTRACE" \
        "--cap-add=SYS_ADMIN" \
        "--cap-add=NET_ADMIN" \
        --ulimit "rtprio=100:100" \
        --network host \
        -v /var/log/coredumps:/var/log/coredumps
            else
                cmd --network host
        fi
        ) \
        --expose 7681 -p 7681:7681 \
        --expose 57575 -p 57575:57575 \
        --entrypoint= --name=$pen_container_name $pen_image "$remote_cmd" $CMD
HEREDOC
    }
    ;;

    # --user "$(id -u):$(id -g)"
    exec) {
        if test "$interactive" = "y"; then
            elisp="$@"
            set -- -e "(pen-force ((do-pen-update $PEN_UPDATE) (pen-force-engine $PEN_ENGINE_Q) (force-temperature $PEN_TEMPERATURE)) $elisp)"
        fi

        # Test quotes:
        # pena --temp 0.9 -u pf-very-witty-pick-up-lines-for-a-topic/1 "new \"zealand" | jq-list-to-lines

        evalcommand="$(cmd-nice ". ~/.emacs.d/pen.el/scripts/setup-term.sh; $(cmd-nice eval "$(cmd-onelineify-safe "$remote_cmd" "$@")")")"
IFS= read -r -d '' shcode <<HEREDOC
docker "$docker_cmd" --env USE_POOL --env USE_NVC --env PEN_USE_GUI $(test "$HAS_TTY" = y && printf -- "%s " -ti ) "$pen_container_name" bash -c $evalcommand
HEREDOC
    }
    ;;

    *)
esac

pen_eval() {
    if test "$DEBUG" = "y"; then
        firstarg="cmd-nice-with-bs $1"
        shift
        set -- "$firstarg" "$@"
    fi

    if test "$penl_strip_pf" = "y"; then
        eval "$@" | sed 's/^pf-//'
    else
        eval "$@"
    fi
}

# pen-pl "$shcode" | pen-tv &>/dev/null

if test "$fuzzy" = "y"; then
    pen_eval "$shcode" | fzf
else
    pen_eval "$shcode"
fi