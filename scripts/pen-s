#!/bin/bash

# A string preprocessor/postprocessor library for pen.el
# With an emphasis on string transformations, rather than characters.

sn="$(basename "$0")"

stdin_exists() {
    ! [ -t 0 ] && ! test "$(readlink /proc/$$/fd/0)" = /dev/null
}

case "$sn" in
    field|all-caps|caps|uppercase|uc|lc|wrl*|wrla|wrla1|awrl) {
        f="$sn"
    }
    ;;

    repeat-string) {
        f=rs
    }
    ;;

    *) {
        f="$1"
        shift
    }
esac

case "$f" in
    indent) {
        level="$1"; : ${level:="1"}
        # printf -- "%s\n" "$level"
        r="$(zsh -c "printf '\t%.0s' {1..$level}")"

        sed -u "s/^/${r}/"
    }
    ;;

    all-caps|caps|uppercase|uc) {
        tr '[:lower:]' '[:upper:]'
    }
    ;;

    split) {
        delim="$1"
        : ${delim:=" "}

        sed -e "s/./&$delim/g" -e "s/$delim\$//"
    }
    ;;

    join) {
        delim="$1"
        : ${delim:=" "}

        sed -z "s~\n~$delim~g" | sed "s/$delim\$//"
    }
    ;;

    lc) {
        tr '[:upper:]' '[:lower:]'
    }
    ;;

    random-line) {
        awk 'BEGIN { "date +%N" | getline seed; srand(seed) } { l[NR]=$0 } END { print l[int(rand() * NR + 1)] }'
    }
    ;;

    rs|repeat-string) {
        count="$1"
        shift

        : ${count:="1"}

        if stdin_exists; then
            IFS= read -rd '' input < <(cat /dev/stdin)
        else
            input="$1"
        fi

        for (( i = 0; i < count; i++ )); do
            printf -- "%s" "$input"
        done
    }
    ;;

    capfirst) {
        sed 's/[a-zA-Z]/\u&/'
    }
    ;;

    capsent|capitalize-sentences) {
        sed 's/[a-z]\+/\u&/'
    }
    ;;

    cap|capitalize) {
        sed 's/[^ _-]*/\u&/g'
    }
    ;;

    rl|repeat-lines) {
        n="$1"; : ${n:="1"}

        awk 1 | awk '{while (c++<'$n') printf $0}'
    }
    ;;

    q|quote) {
        q
    }
    ;;

    lf|last_field) {
        awk '{print $NF}'
    }
    ;;

    field|col|column) {
        delim='[ \t\n]+'

        while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
            -d) {
                delim="$2"
                shift
                shift
            }
            ;;

            *) break;
        esac; done

        field="$1"
        awk -F "$delim" '{print $'$field'}'
    }
    ;;

    sort-anum|sort-alphanumeric) {
        sort -b -d
    }
    ;;

    uniq) {
        awk '!seen[$0] {print} {++seen[$0]}'
    }
    ;;

    dedup) { # without reordering / sorting
        awk '{print(NR"\t"$0)}' | sort -t$'\t' -k2,2 | uniq -u --skip-fields 1 | sort -k1,1 -t$'\t' | cut -f2 -d$'\t'
    }
    ;;

    rf|remove_field) {
        field="$1"
        ofs=" \t "
        awk -F' *\t *' -v myofs="$ofs" 'BEGIN{OFS=myofs}{$'$field' = ""; print $0}'
    }
    ;;

    # onelineify and unonelineify are not entirely reversible. They're just meant for prompt design
    onelineify) {
        sed -z 's/\n/\\n/g'
    }
    ;;

    unonelineify) {
        sed -z 's/\\n/\n/g'
    }
    ;;

    # These are more reversible
    onelineify-safe) {
        pen-encode-string | sed -z 's/\n/\\n/g'
    }
    ;;

    unonelineify-safe) {
        sed -z 's/\\n/\n/g' | pen-decode-string
    }
    ;;

    commalist2list) {
        sed -z -e "s/^\\s*//" -e "s/\\s*$//" |
        sed -z -e "s/, /\\n/g" -e "s/,$//" |
            uniqnosort
    }
    ;;

    list2args) {
        sed -e 's/^/"/' -e 's/$/"/' |
        pen-s join ' '
    }
    ;;

    remove-trailing-whitespace) {
        sed -z -e "s/\s*\$//" -e "s/\n*\$//"
    }
    ;;

    python-gen-next-user-prompt) {
        awk 1 | tac |
            perl -pe "s/(^Out\\[)(\\d+)(.*)/'In [' . (1 + \$2) . ']: ' . \"\\n\" . \$1 . \$2 . \$3/ge if 1 .. 1" |
            tac
    }
    ;;

    *)
esac
