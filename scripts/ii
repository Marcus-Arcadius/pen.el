#!/bin/bash

# Imaginary interpreter
# Version 2.0, bash

lang="$1"
test -n "$lang" || exit 1
shift

memory="$2"

test -n "$MYGIT" && test -d "$MYGIT/semiosis/prompts" && : "${PROMPTS_DIR:="$MYGIT/semiosis/prompts"}"
test -d "prompts" && : "${PROMPTS_DIR:="prompts"}"

lang_lc="$(p "$lang" | tr '[:upper:]' '[:lower:]')"

set -o pipefail

funs="$(penl)"
if ! test "$?" = 0; then
    echo "pen must be running" 1>&2
    exit 1
fi

fun="$(p "$funs" | awk 1 | grep -P "imagine-a-${lang_lc}-interpreter/2" | sed 's/^pf-//')"

default_fun=generic-interpreter/3

file_fun="$fun"
: "${file_fun:="$default_fun"}"

if test -n "$file_fun"; then
    fn="$(p "$file_fun" | tr -s / -)"
    path="$PROMPTS_DIR/prompts/${fn}.prompt"
fi

test -n "$path" && test -f "$path" || exit 1

IFS= read -rd '' kickstarter < <(cat "$path" | yq -r '.subprompts[0].kickstarter' | sed "s/<language>/$lang/g" | pen-str remove-trailing-whitespace);typeset -p kickstarter &>/dev/null
IFS= read -rd '' ii_input_echo_pp < <(cat "$path" | yq -r '.["ii-input-echo-pp"] // empty');typeset -p ii_input_echo_pp &>/dev/null

prompt_the_lm() {
    user_input="$1"

    # TODO Use pena because I want better results
    # Rather, make a penc (pen collect) and use that

    if test -n "$fun"; then
        penf -u "$fun" "$memory" "$user_input"
    else
        penf -u pf-generic-interpreter/3 "$memory" "$user_input" "$lang"
    fi
}

p "${kickstarter} "
memory="${kickstarter} "

while read -e -r user_input; do
    # echo -en "\033[1A\033[2K"
    # echo "$user_input"

    if test -n "$ii_input_echo_pp"; then
        IFS= read -rd '' ii_input_echo < <(printf -- "%s" "$user_input" | eval "$ii_input_echo_pp");typeset -p ii_input_echo &>/dev/null
        if test -n "$ii_input_echo"; then
            printf -- "%s" "$ii_input_echo\n"
            user_input="$user_input\n$ii_input_echo"
        fi
    fi

    # printf -- "%s" "$user_input"

    case "$user_input" in
        "!!"|""|"!1"|"~1") {
            memory="$last_memory"
            user_input="$last_user_input"
        }
        ;;

        "!!"*) {
            memory="$last_memory"
            user_input="${user_input:2}"
        }
        ;;

        "!2"|"~2") {
            memory="$last_last_memory"
            user_input="$last_last_user_input"
        }
        ;;
    esac

    # The prompt functions are not perfect and we want to coerce the output to the form we want
    gen="$(prompt_the_lm "$user_input" | chomp | sed -z 's/^\n\+//')"
    last_last_memory="$last_memory"; last_memory="$memory"
    memory+="$user_input\n"
    p "$gen"
    memory+="$gen"
    p "$memory" > "/tmp/memory.txt"
    last_last_user_input="$last_user_input"; last_user_input="$user_input"
done

p () {
    {
        i=1
        while [ "$i" -lt "$#" ]; do
            eval ARG=\${$i}
            printf -- "%s " "$ARG"
            i=$((i + 1))
        done
        eval ARG=\${$i}
        printf -- "%s" "$ARG"
    } | sed 's/\\n/\n/g'
}