#!/bin/bash

( hs "$(basename "$0")" "$@" </dev/tty ` # Disable tty to pipe content into hs ` )

# If stdin is not pregrepped, it serves as the list of files to search

aqf() { aqf-real "$@"; }

origcmd="$(cmd "$@")"

UPDATE=y

unset CWD

export DO_FILTER=y

if test "$(pwd)" = "/home/shane/var/smulliga/source/git/mullikine/glossaries"; then
    FOLLOW=y
fi

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    -U|-noupdatecache) {
        UPDATE=n
        shift
    }
    ;;

    -j) {
        PREGREPPED=y
        shift
    }
    ;;

    -w) {
        SHOW_FULL_PATH=y
        shift
    }
    ;;

    *) break;
esac; done

sn="$(basename "$0")"
case "$sn" in
    ea) { # deep ack from top
        PARSE_OPTIONS=n
        DEPTH=10
    }
    ;;

    dack) { # deep ack from top
        TOP=y
        DEPTH=10
    }
    ;;

    eat) {
        WORD_BOUNDARIES=y
        DEPTH=10
    }
    ;;

    dac|ead|eackd) { # deep ack
        DEPTH=10
    }
    ;;

    eaf) { # deep ack
        DEPTH=10
        FOLLOW=y
    }
    ;;

    zad|zead) { # deep ack
        DEPTH=10
        USE_ZGREP=y
        FOLLOW=y
    }
    ;;

    iad|eai) { # deep ack, insensitive
        DEPTH=10
        CASE_INSENSITIVE=y
    }
    ;;

    lack) { # literal ack
        TOP=y
        LITERAL=y
        DEPTH=10
    }
    ;;
esac

: ${PARSE_OPTIONS:="y"}

export PARSE_OPTIONS
export UPDATE
export SHOW_FULL_PATH
export DEPTH
export WORD_BOUNDARIES
export CASE_INSENSITIVE
export TOP
export LITERAL
export FOLLOW
export USE_ZGREP

is_tty() {
    # If stout is a tty
    [[ -t 1 ]]
}

pager() {
    if is_tty; then
        tless -rS "$@"
    else
        cat
    fi
}

#export EXCLUDE_VENDOR
#export EXCLUDE_GIT
#export OCCUR
#export PCRE
#export CASE_INSENSITIVE
#export LITERAL
#export TOP
#export KNOWN_TEXT_FILES_ONLY
#export SYMLINK_RESULTS
#export UPDATE

# (define-key compilation-button-map (kbd "C-m") 'grep-go-vim)
read -r -d '' maps <<- 'HEREDOC'
	(define-key compilation-button-map (kbd "C-m") 'compile-goto-error)
	(define-key compilation-button-map (kbd "RET") 'compile-goto-error)
	HEREDOC

# lit "(cd $(aqf "$CWD"))(grep-mode)$(p "$maps" | tr -d '\n')"

if test "$PREGREPPED" = "y"; then
    # This is for gli
    cd /
fi

CWD="$(pwd)"

# ivy-occur-grep-mode
# ecmd="(cd $(aqf "$CWD"))(ivy-occur-grep-mode)$(p "$maps" | tr -d '\n')$occur_string(visual-line-mode -1)"
# ecmd="(cd $(aqf "$CWD"))(grep-mode)(ivy-wgrep-change-to-wgrep-mode)$(p "$maps" | tr -d '\n')$occur_string(visual-line-mode -1)"
# (let ((wgrep-header/footer-parser (lambda ()))) (ivy-wgrep-change-to-wgrep-mode))
# (cl-letf (((symbol-function 'wgrep-prepare-header/footer) #'ignore))(ivy-wgrep-change-to-wgrep-mode))

# ecmd="(cd $(aqf "$CWD"))(grep-mode)(ivy-wgrep-change-to-wgrep-mode)$(p "$maps" | tr -d '\n')$occur_string(visual-line-mode -1)"

ecmd="(cd $(aqf "$CWD"))(grep-mode)"

# pl "$ecmd" | tv &>/dev/null

# This is needed to prevent emacs from closing instantly if the command fails for whatever reason.
ecmd="(ignore-errors $ecmd)"

# ci is still slow if the cached file is huge
# IFS= read -rd '' input < <(export UPDATE; odn ci -t 300 find-and-grep "$@" | show-pipe)

# This is needed for emacs' sh-notty
stdin_exists() {
    ! [ -t 0 ] && ! test "$(readlink /proc/$$/fd/0)" = /dev/null
}

grep() {
    if test "$PARSE_OPTIONS" = "y"; then
        hs-grep -Hn "$@"
    else
        hs-grep -Hn -- "$@"
    fi
}

filter() {
    if test "$DO_FILTER" = "n"; then
        cat
    else
        # grep -v cscope-ctags | 
        sed -e "/log\/build_/d" -e "/\/tags:/d" | sed 's/(standard input):\s*[0-9]\+://'
    fi
}

# stdin is either grep output for display or a list of files/grep output
# to use as the files to be used in grep

if stdin_exists; then
    if test "$PREGREPPED" = "y"; then
        IFS= read -rd '' input < <(awk 1 | filter)
    else
        # IFS= read -rd '' input < <(awk 1 | filter | xargs grep "$@")

        IFS= read -rd '' input < <(awk 1 | cut -d : -f 1 | filter | xargs grep -Hn "$@" -- 2>/dev/null; )

        # IFS= read -rd '' input < <(awk 1 | filter | while read line; do grep "$@" "$line" 2>/dev/null; done)

        #CMD="$(lit -s "$@")"
        #IFS= read -rd '' input < <(awk 1 | while read line; do 
        #    if test "$PARSE_OPTIONS" = "y"; then
        #        grep "$@" "$line" 2>/dev/null;
        #    else
        #        CMD="$(cmd "$@")"
        #        : ${CMD:="$(cmd "$@")"}

        #        grep "$CMD" "$line" 2>/dev/null;
        #    fi

        #    grep "$@" "$line" 2>/dev/null;
        #done)
    fi
else
    IFS= read -rd '' input < <(export UPDATE; odn ci -t 300 find-and-grep "$@" | filter)
fi

if [ -n "$input" ]; then
    {
        if test "$PREGREPPED" = "y"; then
            echo "pregrepped input"
        else
            echo "cd $(aqf $CWD); $0 $origcmd" | mnm
        fi
        echo These extra lines are needed for the compilation-mode issue
        echo See "wgrep-prepare-header/footer"
        echo
        printf -- "%s" "$input" |
        {
            if test "$PREGREPPED" = "y" && printf -- "%s" "$input" | empty-line-exists; then
                awk 1 | sed "0,/^$/d"
            else
                cat
            fi
        }
    } | dos2unix | {
        if is_tty; then
            # mnm | orspe -noonly -e "$ecmd"
            # Sadly, mnm appears to break wgrep-mode
            # grep-mode is fine.
            mnm | orspe -noonly -e "$ecmd"
            result="$?"
            if ! test "$result" -eq 0; then
                printf -- "%s\n" "$input" | pager
            fi
        else
            cat

            #if test "$PREGREPPED" = "y"; then
            #    cat
            #else
            #    sed "1,4d"
            #fi
        fi
    }
else
    printf -- "%s\n" "No results" 1>&2
    exit 1
fi
