#!/bin/bash
export TTY

# NLÂ·SH
# Version 2.0, bash
sn="$(basename "$0")"

inside-docker-p() {
    test -f /.dockerenv
}

export INSIDE_EMACS

: "${USE_COMINT:="y"}"
: "${USE_TERM:="n"}"

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    -nd) {
        export NO_DOCKER=y
        shift
    }
    ;;

    -nt) {
        export NO_TERM=y
        shift
    }
    ;;

    -com|-comint) {
        USE_COMINT=y
        USE_TERM=n
        shift
    }
    ;;

    -term) {
        USE_COMINT=n
        USE_TERM=y
        shift
    }
    ;;

    -nc|-nocomint) {
        USE_COMINT=n
        shift
    }
    ;;

    *) break;
esac; done

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
     -nv) {
         # Used by cterm-docker, not comint
         export USE_NVC=y
         USE_COMINT=n
         USE_TERM=y
         shift
     }
     ;;

     *) break;
esac; done

export USE_COMINT
export USE_TERM

: "${SHELL:="sh"}"

if { ! test "$NO_DOCKER" = y; } && { ! inside-docker-p; } && { test "$USE_COMINT" = y || test "$USE_TERM" = y; }; then
    if test -z "$OS_OR_LANG"; then
        if test "$#" -eq 0 && test -f /etc/issue; then
            OS_OR_LANG="$(cat /etc/issue | sed 's/\\.*//' | chomp) ($(basename $SHELL))"
        elif test "$#" -eq 0; then
            OS_OR_LANG="$(pen-readln "OS (and/or shell)")"
        else
            OS_OR_LANG="$@"
        fi
    fi

    if test "$USE_TERM" = y; then
        cterm-docker nlsh -term -os-or-lang "$OS_OR_LANG" -shell "$SHELL" "$@"
    elif test "$USE_COMINT" = y; then
        export NORL=y
        pen sh nlsh -nt -norl -os-or-lang "$OS_OR_LANG" -shell "$SHELL" "$@"
    fi
    # pen sh nvc nlsh "$@"
    exit "$?"
fi

CMD="$(cmd-nice-posix "$@")"

while [ $# -gt 0 ]; do opt="$1"; case "$opt" in
    "") { shift; }; ;;
    -norl) {
        NORL=y
        shift
    }
    ;;

    -shell) {
        SHELL="$2"
        shift
        shift
    }
    ;;

    -os-or-lang) {
        OS_OR_LANG="$2"
        shift
        shift
    }
    ;;

    *) break;
esac; done

if test -z "$OS_OR_LANG"; then
    if test "$#" -eq 0 && test -f /etc/issue; then
        OS_OR_LANG="$(cat /etc/issue | sed 's/\\.*//' | chomp) ($(basename $SHELL))"
    elif test "$#" -eq 0; then
        OS_OR_LANG="$(pen-readln "OS (and/or shell)")"
    else
        OS_OR_LANG="$@"
    fi
fi

if ! test "$NORL" = "y"; then
    pen-rlwrap "$sn" -norl "$@"
    exit $?
fi

nlsh-logo 1>&2

# pf-code-snippet-from-natural-language/2
# pf-nlsh/2

case "$sn" in
    nlsh) { prompt=pf-nlsh/2; } ;;
    nlsc) { prompt=pf-code-snippet-from-natural-language/2; } ;;

    *)
esac

if test "$USE_COMINT" = y && ! printf -- "%s\n" "$INSIDE_EMACS" | grep -q -P 'comint$'; then
    comint -p "$OS_OR_LANG: " -E "nlsh -shell $SHELL $CMD"
    exit $?
fi

test -n "$OS_OR_LANG" || {
    echo "Requires 1 argument: OS or lang" 1>&2
    exit 2
}

echo Enter your commands in natural language.
echo

export USE_CONVERSATION_MODE=y

# rlwrap openai-complete.sh prompts/nlsh-2.prompt "$OS_OR_LANG"

while IFS=$'\n' read -p "${OS_OR_LANG}: " -r nlcommand; do
    if test "$nlcommand" = "!!"; then
        nlcommand="$lastcmd"
        UPDATE=y
    else
        UPDATE=
    fi

    export UPDATE

    pena "$prompt" "${OS_OR_LANG}" "$nlcommand" | jq -r ".[]"
    # pena "$prompt" "${OS_OR_LANG}" "$nlcommand" | jq -r ". | map(length)[]"

    lastcmd="$nlcommand"
done
